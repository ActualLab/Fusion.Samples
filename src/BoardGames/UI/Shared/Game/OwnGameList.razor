@using System.Threading
@using System.Collections.Immutable
@using System.Security
@inherits LiveComponentBase<OwnGameList.Model, int?>
@inject IGameService Games
@inject IGameUserService GameUsers
@inject ImmutableDictionary<string, IGameEngine> GameEngines;
@inject Session Session

@{
    var state = State.LastValue;
    var error = State.Error;
}

<div class="@CssClass">
    <WhenUpdateError Exception="@error" />
    @if (state.Games.Count > 0) {
        <Heading Size="HeadingSize.Is4">@Title</Heading>
        <Table Narrow="true" Striped="true">
            <TableHeader>
                @if (GameEngineId != null) {
                    <TableHeaderCell>Game type</TableHeaderCell>
                }
                <TableHeaderCell>Stage</TableHeaderCell>
                <TableHeaderCell>Players</TableHeaderCell>
                <TableHeaderCell>Created</TableHeaderCell>
                <TableHeaderCell></TableHeaderCell>
            </TableHeader>
            <TableBody>
                @foreach(var game in state.Games) {
                    <TableRow>
                        @if (GameEngineId != null) {
                            <TableHeaderCell>
                                <a href="@LinkBuilder.Game(game.EngineId)">@GameEngines[game.EngineId].Title</a>
                            </TableHeaderCell>
                        }
                        <TableRowCell>
                            <Badge Color="@GetStageColor(game.Stage)">@game.Stage</Badge>
                        </TableRowCell>
                        <TableRowCell>
                            <GameUsersBadge Users="@game.Players.Select(p => state.GetUser(p.UserId))"/>
                        </TableRowCell>
                        <TableRowCell>
                            <MomentsAgoBadge Time="@game.CreatedAt"/>
                        </TableRowCell>
                        <TableRowCell>
                            <Button Size="Size.Small" Color="Color.Info"
                                    Type="@ButtonType.Link" To="@(LinkBuilder.Game(game.EngineId, game.Id))">Open</Button>
                        </TableRowCell>
                    </TableRow>
                }
            </TableBody>
        </Table>
    }
</div>

@code {
    public record Model {
        public ImmutableList<Game> Games { get; init; } = ImmutableList<Game>.Empty;
        public ImmutableDictionary<long, GameUser> Users { get; init; } = ImmutableDictionary<long, GameUser>.Empty;

        public GameUser GetUser(long userId) => Users.GetValueOrDefault(userId) ?? GameUser.None;
    }

    [Parameter]
    public string CssClass { get; set; } = "";
    [Parameter]
    public string Title { get; set; } = "";
    [Parameter]
    public string? GameEngineId { get; set; }
    [Parameter]
    public GameStage? GameStage { get; set; }

    protected override Task OnParametersSetAsync()
    {
        if (string.IsNullOrEmpty(Title)) {
            Title = $"Your {(GameStage.HasValue ? GetStageName(GameStage.Value) : "")} games";
            if (GameEngineId != null) {
                var gameEngine = GameEngines[GameEngineId];
                Title += $"of {gameEngine.Title}";
            }
        }
        return base.OnParametersSetAsync();
    }

    protected Color GetStageColor(GameStage stage)
        => stage switch {
            Abstractions.GameStage.New => Color.Light,
            Abstractions.GameStage.Playing => Color.Primary,
            Abstractions.GameStage.Ended => Color.Dark,
            _ => throw new ArgumentOutOfRangeException(nameof(stage))
            };

    protected string GetStageName(GameStage stage)
        => stage switch {
            Abstractions.GameStage.New => "newly created",
            Abstractions.GameStage.Playing => "ongoing",
            Abstractions.GameStage.Ended => "finished",
            _ => throw new ArgumentOutOfRangeException(nameof(stage))
            };

    protected override async Task<Model> ComputeStateAsync(CancellationToken cancellationToken)
    {
        var count = Locals.Value ?? 100;
        try {
            var games = await Games.ListOwnAsync(GameEngineId, GameStage, count, Session, cancellationToken);
            var userIds = games.SelectMany(g => g.Players.Select(p => p.UserId)).ToHashSet();
            var users = await userIds.ParallelSelectToListAsync((id, ct) => GameUsers.FindAsync(id, ct), cancellationToken);
            return new Model() {
                Games = games,
                Users = users.Where(u => u != null).ToImmutableDictionary(u => u!.Id)!,
            };
        }
        catch (SecurityException) {
            return new Model();
        }
    }
}
